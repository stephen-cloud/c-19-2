{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Note You can find me at stephen@stephen.cloud and https://www.linkedin.com/in/stephenharrison/ and https://github.com/stephen-cloud/ and https://www.thelucidcoder.com (nothing interesting there yet.) Here is an end-to-end tutorial that shows how to create the C-19 Autobody sample application in https://github.com/stephen-cloud/c-19-autobody from scratch. This documentation is https://stephen-cloud.github.io/c-19-autobody/ . You can see the finished application at https://c-19-autobody.stephen.cloud . You can stop at the end of each section and have something interesting working. Why C-19 Autobody? Well, I was laid off from my online retail company as a result of COVID-19. Sales were down. A lot, and then some. So between talking to recruiters and having interviews, I learned lots of things I didn't know and put them together. And C-19 because I'm helping a buddy of mine with tech in his autobody shop. And I just saw an article on the C-19 antibody. Here are the features and technologies we're using to implement in this demo. Feature Technology A type safe(r) programming language TypeScript Cloud-native and serverless AWS Amplify A User Interface React Material Sign-up, sign-in, forgot password AWS Amplify Authentication A back-end API GraphQL schema definition + AWS Amplify GraphQL API A database AWS Amplify API + AWS DynamoDB Subscribe to data changes; handle off-line edits AWS AppSync Who is this for? \u00b6 If you know React Material, Material Table, AWS Amplify, or any of the technologies above, you can skip the tutorials for those parts. The completed files are always shown in the section \"The upshot\" so you can get going with the bits you don't know so well. The upshot \u00b6 After you follow all the steps, you'll have a React Material web application backed by a GraphQL backend in AWS. The application manages the basic elements of an Autobody shop. The application is only a demo: It doesn't actually fix cars.","title":"Home"},{"location":"#who-is-this-for","text":"If you know React Material, Material Table, AWS Amplify, or any of the technologies above, you can skip the tutorials for those parts. The completed files are always shown in the section \"The upshot\" so you can get going with the bits you don't know so well.","title":"Who is this for?"},{"location":"#the-upshot","text":"After you follow all the steps, you'll have a React Material web application backed by a GraphQL backend in AWS. The application manages the basic elements of an Autobody shop. The application is only a demo: It doesn't actually fix cars.","title":"The upshot"},{"location":"add-table-view/","text":"We just got the button hooked up and printed out the state. Clearly JSON is not a good format for mortals. Let's create a table. Luckily it's easy. Import more elements from @material-ui/core . import { Table , TableHead , TableRow , TableCell , TableBody } from '@material-ui/core' ; Replace the return statement with return ( <> < Button onClick = { onClick } > Add vehicle < /Button> < Table > < TableHead > < TableRow > < TableCell > Make < /TableCell> < TableCell > Model < /TableCell> < TableCell > Mileage < /TableCell> < /TableRow> < /TableHead> < TableBody > { vehicles . map (( vehicle ) => ( < TableRow > < TableCell > { vehicle . make } < /TableCell> < TableCell > { vehicle . model } < /TableCell> < TableCell align = \"right\" > { vehicle . mileage } < /TableCell> < /TableRow> )) } < /TableBody> < /Table> < /> ); Let's unpack that. We need <> ... </> around all the elements because as there can only be one top-level element. We have two: The <Button> and the <Table> . Hint The table definition is the analog of basic HTML tables with a head and a body. The { ... } inside the <TableBody> lets us run display logic, in this case loop over the vehicles and generate table rows. There must be only one statement inside { ... } and that code must return React elements. Try it. Not bad. But there's more. Layout likes to be on a grid \u00b6 Responsive UI frameworks are usually based around the idea of layout in twelve columns. React is one of those frameworks. The layout of the page without a grid is actually OK. If we had lots of elements it might be hard to add all the spacing by hand to get things even. And if we didn't like it there'd be lots of place to change it. We can control all the layout you need with grids. Another thing's irksome. The button's always on a line on its own, even when the page is wide enough to have the button on the left and the table in the remaining space. There's room. Let's do it. Add a <Grid> with some spacing around the <Button> and <Table> elements. import { Grid } from '@material-ui/core' ; < Grid container spacing = { 2 } > < Button onClick = { onClick } > Add vehicle < /Button> < Table > ... < /Table> < /Grid> Refresh. Not much difference. That's because a <Grid container> lays out <Grid item> s and we don't have any yet. Add the two items inside the container. < Grid container spacing = { 2 } > < Grid item > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item > < Table > ... < /Table> < /Grid> This lays out the button and table items side-by-side. Try resizing the screen. Things move around as the screen size changes. We want to lay out grid items in an actual grid. We saw the default for <Grid item> is to flow items. That's really not very gridy. We can specify breakpoint values for items (any number of xs , sm , md , lg , and xl values) with a column span, which can be 1 (1 column) through 12 (the whole row.) Each breakpoint defines the behavior of responsive design, the way page layout changes to accommodate different screen sizes. Info See https://material-ui.com/customization/breakpoints/ for the details. So with all that, now < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < Table > ... < /Table> < /Grid> < /Grid> will layout both the button and the table full width if the screen size is less than 600px. and side-by-side if the size if 600px or above. Try waggling the bottom-right corner of the browser around to see the button and table move relative to each other. This is responsive design at work with defined columns. Hint <Grid container spacing={??}> adds spacing between cells of the grid: It does not affect margins of the grid container itself. You can try different values for the padding and see this work. The upshot \u00b6 We built a super simple application that has a UI and a backend. We see how the application is synchronized across all open browsers. We're starting to use responsive design. iPad portrait iPad landscape We added an array of Vehicles as state, a button to add a new one with some random values for the fields for make , model , and mileage , and a list of them that updates as we add a vehicle. The table's pretty lame: There's no pagination, editing, sorting, or filtering. That's in our future. Here's the whole file, Vehicles.tsx with everything we did. import React from 'react' ; import { Button , Table , TableHead , TableRow , TableCell , TableBody , Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { uuid } from 'uuidv4' ; function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); setVehicles ([... vehicles , vehicle ]); } function onClick ( event : React.MouseEvent ) { console . log ( 'event' , event ); addVehicle (); event . preventDefault (); } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < Table > < TableHead > < TableRow > < TableCell > Make < /TableCell> < TableCell > Model < /TableCell> < TableCell > Mileage < /TableCell> < /TableRow> < /TableHead> < TableBody > { vehicles . map (( vehicle ) => ( < TableRow > < TableCell > { vehicle . make } < /TableCell> < TableCell > { vehicle . model } < /TableCell> < TableCell align = \"right\" > { vehicle . mileage } < /TableCell> < /TableRow> )) } < /TableBody> < /Table> < /Grid> < /Grid> ); } export default Vehicles ; Now we're going to integrate the UI we just made with the backend database. Adding a \"delete all\" button is easy \u00b6 Add the button < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < Button onClick = { onDeleteAll } > Delete all < /Button> < /Grid> And a handler function onDeleteAll(event: React.MouseEvent) { console.log('event', event); DataStore .delete(Vehicle, Predicates.ALL) .then(console.log) .catch(console.error); event.preventDefault(); } Suddenly, integrating UI and backend looks not as hard as we'd thought.","title":"Add a table"},{"location":"add-table-view/#layout-likes-to-be-on-a-grid","text":"Responsive UI frameworks are usually based around the idea of layout in twelve columns. React is one of those frameworks. The layout of the page without a grid is actually OK. If we had lots of elements it might be hard to add all the spacing by hand to get things even. And if we didn't like it there'd be lots of place to change it. We can control all the layout you need with grids. Another thing's irksome. The button's always on a line on its own, even when the page is wide enough to have the button on the left and the table in the remaining space. There's room. Let's do it. Add a <Grid> with some spacing around the <Button> and <Table> elements. import { Grid } from '@material-ui/core' ; < Grid container spacing = { 2 } > < Button onClick = { onClick } > Add vehicle < /Button> < Table > ... < /Table> < /Grid> Refresh. Not much difference. That's because a <Grid container> lays out <Grid item> s and we don't have any yet. Add the two items inside the container. < Grid container spacing = { 2 } > < Grid item > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item > < Table > ... < /Table> < /Grid> This lays out the button and table items side-by-side. Try resizing the screen. Things move around as the screen size changes. We want to lay out grid items in an actual grid. We saw the default for <Grid item> is to flow items. That's really not very gridy. We can specify breakpoint values for items (any number of xs , sm , md , lg , and xl values) with a column span, which can be 1 (1 column) through 12 (the whole row.) Each breakpoint defines the behavior of responsive design, the way page layout changes to accommodate different screen sizes. Info See https://material-ui.com/customization/breakpoints/ for the details. So with all that, now < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < Table > ... < /Table> < /Grid> < /Grid> will layout both the button and the table full width if the screen size is less than 600px. and side-by-side if the size if 600px or above. Try waggling the bottom-right corner of the browser around to see the button and table move relative to each other. This is responsive design at work with defined columns. Hint <Grid container spacing={??}> adds spacing between cells of the grid: It does not affect margins of the grid container itself. You can try different values for the padding and see this work.","title":"Layout likes to be on a grid"},{"location":"add-table-view/#the-upshot","text":"We built a super simple application that has a UI and a backend. We see how the application is synchronized across all open browsers. We're starting to use responsive design. iPad portrait iPad landscape We added an array of Vehicles as state, a button to add a new one with some random values for the fields for make , model , and mileage , and a list of them that updates as we add a vehicle. The table's pretty lame: There's no pagination, editing, sorting, or filtering. That's in our future. Here's the whole file, Vehicles.tsx with everything we did. import React from 'react' ; import { Button , Table , TableHead , TableRow , TableCell , TableBody , Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { uuid } from 'uuidv4' ; function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); setVehicles ([... vehicles , vehicle ]); } function onClick ( event : React.MouseEvent ) { console . log ( 'event' , event ); addVehicle (); event . preventDefault (); } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < Table > < TableHead > < TableRow > < TableCell > Make < /TableCell> < TableCell > Model < /TableCell> < TableCell > Mileage < /TableCell> < /TableRow> < /TableHead> < TableBody > { vehicles . map (( vehicle ) => ( < TableRow > < TableCell > { vehicle . make } < /TableCell> < TableCell > { vehicle . model } < /TableCell> < TableCell align = \"right\" > { vehicle . mileage } < /TableCell> < /TableRow> )) } < /TableBody> < /Table> < /Grid> < /Grid> ); } export default Vehicles ; Now we're going to integrate the UI we just made with the backend database.","title":"The upshot"},{"location":"add-table-view/#adding-a-delete-all-button-is-easy","text":"Add the button < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < Button onClick = { onDeleteAll } > Delete all < /Button> < /Grid> And a handler function onDeleteAll(event: React.MouseEvent) { console.log('event', event); DataStore .delete(Vehicle, Predicates.ALL) .then(console.log) .catch(console.error); event.preventDefault(); } Suddenly, integrating UI and backend looks not as hard as we'd thought.","title":"Adding a \"delete all\" button is easy"},{"location":"amplify/","text":"AWS Amplify is a pretty great. It lets you add lots of production quality features to your web and mobile apps that you'd just have to do by hand otherwise. It's a managed service and tool chain for mobile and web apps. Feature What it does How we use it in C-19 Autobody API Lets you define arbitrary APIs using REST or GraphQL. API endpoints can be backed by AWS Lambdas. GraphQL endpoint are backed by DynamoDB. We use some of the available GraphQL queries and mutations. Auth Uses AWS Cognito to create a full-featured sign-up, sign-on, forgot my password, and so on. We use all the things. We get a full-featured authentication experience out-of-the-box with very little extra effort. DataStore A cross-device data storage synchronization that uses GraphQL. You can also subscribe to changes in data from other users and devices. This works whether you're online or offline: Synchronization uses optimistic locking. As we're storing data through the DataStore API, the data will be stored in DynamoDB. Other devices (even browser tabs) will subscribe and update in realtime. Interactions Amplify lets you integrate with Amazon Alexa for chat bots and similar Predictions Integrates Amazon Machine Learning. PubSub Amplify provides connectivity to message systems. Push Notifications Uses Amazon Pinpoint for segmentation and campaigns Storage Can upload images and other data to S3 from an application There's already a super duper \"Getting started\" for Amplify \u00b6 So let's do some of that now. We're going to branch out on our own when it's time to connect up the UI to the backend. That's because we're using React Material, Material Tables and have our own schema. Sp just just the following sections Prerequisites Set up fullstack project Instead of editing src/index.js , edit src/index.tsx since we're using TypeScript. You need to make a couple of changes \u00b6 When you're asked \"Do you want to edit the schema now?\" say yes and replace the contents with type Vehicle @model { id: ID! make: String! model: String! mileage: Int } We're not going to do to-dos. After all this, make sure yarn start still works. Handy commands \u00b6 amplify console opens the AWS Amplify console for the current project. amplify mock api does exactly what it says. Open a browser at the endpoint and execute some GraphQL commands. OK. So that last one might be a stretch. That's why we're not going to use the GraphQL API directly. We're going to use higher level abstraction, Amplify DataStore. The upshot \u00b6 TBD: what we did","title":"Add AWS Amplify"},{"location":"amplify/#theres-already-a-super-duper-getting-started-for-amplify","text":"So let's do some of that now. We're going to branch out on our own when it's time to connect up the UI to the backend. That's because we're using React Material, Material Tables and have our own schema. Sp just just the following sections Prerequisites Set up fullstack project Instead of editing src/index.js , edit src/index.tsx since we're using TypeScript.","title":"There's already a super duper \"Getting started\" for Amplify"},{"location":"amplify/#you-need-to-make-a-couple-of-changes","text":"When you're asked \"Do you want to edit the schema now?\" say yes and replace the contents with type Vehicle @model { id: ID! make: String! model: String! mileage: Int } We're not going to do to-dos. After all this, make sure yarn start still works.","title":"You need to make a couple of changes"},{"location":"amplify/#handy-commands","text":"amplify console opens the AWS Amplify console for the current project. amplify mock api does exactly what it says. Open a browser at the endpoint and execute some GraphQL commands. OK. So that last one might be a stretch. That's why we're not going to use the GraphQL API directly. We're going to use higher level abstraction, Amplify DataStore.","title":"Handy commands"},{"location":"amplify/#the-upshot","text":"TBD: what we did","title":"The upshot"},{"location":"awesome-table/","text":"As we already saw, the table that displays all the vehicles is lame. It does not paginate and it only works on all the vehicles at once. It does not let you create, update, or update the data within the table. In addition, we had to create the table from scratch using the basic elements of Material UI. Let's fix that. Or rather, let someone else fix it for us. Enter the magnificent Material Table, https://material-table.com . We're just about to make some big changes to Vehicle.tsx with quite a few steps. As always, if you want to skip the steps and see the end result check \"The upshot\" section. Start simple \u00b6 Let's hook up Material Table to the existing data. Add the dependency yarn add material-table Import it. import MaterialTable from 'material-table' There's a ton of options for each column so we use the type Column to leverage editor completion. Always nice. numeric aligns right. And define some column metadata. import MaterialTable , { Column } from 'material-table' ; const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" }, ]; Now we have everything we need to replace our old table with the nice one. return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < MaterialTable data = { vehicles } columns = { columns } /> < /Grid> < /Grid> ); Try it. Ugh. We broke something and the page is blank. Material Table requires a mutable id on each row. AWS Amplify provides a different id , but it's readonly . So things won't work if you just pass a Vehicle around for rows. A quick fix is map each Vehicle to an untyped object. I found this out and figured out the fix so you don't have to. The function rowMapper(...) does this. function rowMapper ( vehicles : Vehicle []) : Vehicle [] { return vehicles . map ( vehicle => { return { ... vehicle } }); } Now <MaterialTable> looks like return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < MaterialTable data = { rowMapper ( vehicles )} columns = { columns } /> < /Grid> < /Grid> ); Try it again. Ugh. Although Material Table is already looking promising, it looks like we need some icons. Follow the instructions in https://material-table.com/#/docs/install . Yay. This table's looking properly amazing. Search works for string and numeric fields. But of course we're not stopping here \u00b6 We're not, because this is a tutorial on Material Table and how to integrate with AWS Amplify. There's still lots to do before we're awesome. Try pressing the \"ADD VEHICLE\" button. See the total increase? Cool. Press it 1,000 more times. It slows down. A lot. Retrieving all the vehicles every time clearly doesn't work. Not so cool. Let's paginate. But first\u2014in a bold move bordering on reckless\u2014remove the vehicles state and the fetchAll() function. Comment it out in subscriber() . We're going need something here, and this will remind us. function Vehicles() now starts function Vehicles() { useEffect (() => { function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); // fetchAll(); } const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, []); function addVehicle() { ... The data property in <MaterialTable ... /> can also take a function instead of a simple array. Fields in the function argument, the query, allow us to retrieve just the right single page of vehicles, solving the fetch-everything-at-once ugliness. We'll take query.page and query.pageSize and call DataStore.query() to get just the right page. Oh, and data needs a Promise now. Oh, and DataStore.query() needs a predicate now, even the always-true predicate. import MaterialTable , { Column , Query , QueryResult } from 'material-table' ; function data ( query : Query < Vehicle > ) : Promise < QueryResult < Vehicle >> { return new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; DataStore . query ( Vehicle , Predicates . ALL , thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }); }) . catch ( reject ); }) } We broke some things \u00b6 Only first page is displayed. And we don't refresh when we add a vehicle. (You might have noticed we set totalCount to a large number to get something going until we solve this.) There are a couple of reasons for this. For pagination to work correctly, Material Table needs to know the total number of rows. That used to be easy because we had all the rows. But now we only have a page at a time. Harder than you think It's because we're using GraphQL backed by DynamoDB. DynamoDB does not work like SQL where you can SELECT COUNT(*) ... or something. There's no way to get the total number without scanning a whole table, which is prohibitively expensive for large tables. We're going to solve this another way. But fair warning, this is going to feel like we don't know what we're doing. Search is broken now too \u00b6 It looks like there's a bad interaction between what we're now doing in Material Table and how we're using Amplify DataStore to fetch a page. Let's fix it. DataStore.query(...) takes a predicate, specifically a function that takes a ModelPredicate<Vehicle> and returns one too. Our task is to add some criteria to this predicate. We can take query.search and create criteria. Start with the make field in vehicle. function data ( query : Query < Vehicle > ) : Promise < QueryResult < Vehicle >> { return new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; function searchCriteria ( predicate : ModelPredicate < Vehicle > ) : ModelPredicate < Vehicle > { return predicate . make ( \"contains\" , query . search ); } DataStore . query ( Vehicle , searchCriteria , thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }); }) . catch ( reject ); }) } Now we can type a search term and get matching vehicle makes. Nice. Compound criteria are constructed like this predicate . make ( \"contains\" , query . search ). model ( \"contains\" , query . search ) but when we try it we discover that is an and criterion. We need or . This is the right incantation for that. function searchCriteria ( predicate : ModelPredicate < Vehicle > ) : ModelPredicate < Vehicle > { return predicate . or ( or => or . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search )); } Adding search on mileage is easy too: We just have to think of a reasonable semantics. \"Is greater than or equal\" is probably better than \"contains these digits.\" Now we have function searchCriteria ( predicate : ModelPredicate < Vehicle > ) : ModelPredicate < Vehicle > { return predicate . or ( or => or . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search ) . mileage ( \"ge\" , parseInt ( query . search , 10 ))); } Search is fixed. And the \u2265 semantics for mileage looks like a good call. We see there's a default title that's not very useful. Let's leave all the polish like this until after everything's working. Triggering refresh \u00b6 We can add vehicles as before, but they're not showing up in the table. We need to connect the subscription to the table. It's pretty easy if you know how. We need to add a reference to the table so we can use to trigger a refresh. import React , { useEffect , createRef } from 'react' ; import MaterialTable , { Column , Query , QueryResult , MaterialTableProps } from 'material-table' const tableRef = createRef < MaterialTableProps < Vehicle >> (); Now bind it to the table like this. < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } /> Now all we have to do to trigger a refresh on the table when we get an event from the subscription. It's a bit finicky. We going to trip the table's onQueryChange() hook. That function requires some arguments, which we mostly relay from the current table state. There are a couple of things we didn't figure out how to get like the current orderBy . Irksome, but not a deal-breaker. Ever wonder what that empty [] was in the useEffect() hook declaration? Well it's for passing dependencies. tableRef is a dependency. The new useEffect \u00b6 useEffect (() => { function subscriber ( msg : SubscriptionMessage < Vehicle > ) { console . log ( 'subscription' , msg . opType ); if ( tableRef . current ) { const table = tableRef . current ; if ( table . onQueryChange ) { table . onQueryChange ({ filters : [], orderBy : {}, orderDirection : 'asc' , page : table.page || 0 , pageSize : table.options?.pageSize || 5 , search : table.options?.searchText || '' }); } } }; const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, [ tableRef ]); Try it. Much better. Remember that if you want to delete all existing vehicles and start adding new one, you can add a <Button> and call DataStore . Like this < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < Button onClick = { onDeleteAll } > Delete all < /Button> < /Grid> function onDeleteAll ( event : React.MouseEvent ) { DataStore . delete ( Vehicle , Predicates . ALL ) . then ( console . log ) . catch ( console . error ) event . preventDefault (); } But the bloom is off the rose whe we ca see just how much we're redrawing of the table. We'll see if we can fix that later when we polish. Manipulating items from the table itself \u00b6 Note If you want to skip the details of making rows editable, fast-forward to The upshot . It's quite a bit of faffing about for here. The \"ADD VEHICLE\" button has a bunch of issues. Let's move that functionality to the table. Removing buttons simplifies the layout. return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } > < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } /> < /Grid> < /Grid> ); Material Table provides hooks for CRUD operations right in the table. The hooks are defined as editable ?: { isEditable ?: ( rowData : RowData ) => boolean ; isDeletable ?: ( rowData : RowData ) => boolean ; onRowAdd ?: ( newData : RowData ) => Promise < any > ; onRowUpdate ?: ( newData : RowData , oldData? : RowData ) => Promise < any > ; onRowDelete ?: ( oldData : RowData ) => Promise < any > ; } Let's add them one-by-one. We can start with no hooks because all hooks are optional. const editable = { }; < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } /> Test it. Nothing does nothing successfully. Before we can edit a row that has optional fields\u2014our mileage field\u2014we need to define a value returned when omitted. This is easy: Just add it to the Column . const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" , emptyValue : '' }, ]; Adding a row \u00b6 Add a function to edit a row. We get save and cancel buttons for free. const onRowAdd = ( newData : Vehicle ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { const add = new Vehicle ({ make : newData.make , model : newData.model , mileage : newData.mileage }); DataStore . save ( add ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , } Let's unpack this. onRowAdd returns a Promise . That's easy: we just have to call resolve or reject like we already know. We create a new Vehicle with the fields setTimeout(() => {...}) returns a Timeout (1000ms feels right.) We call clearTimeout() only if the save succeeds. Otherwise it's standard Promise handling. Now enable deleting a row \u00b6 The function for onRowDelete looks very similar to that for onRowAdd . const onRowDelete = ( oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . delete ( Vehicle , oldData . id ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , onRowDelete , } Try it. Yay, a rubbish bin. Still noticing quite a bit of table flash. Updating a row \u00b6 const onRowUpdate = ( newData : any , oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . query ( Vehicle , oldData . id ) . then ( original => { const updated = Vehicle . copyOf ( original , updated => { updated . make = newData . make updated . model = newData . model updated . mileage = parseInt ( newData . mileage , 10 ) }); return DataStore . save ( updated ); }) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) The last one's a bit sneaky. It's chaining Promise s by returning a Promise from the first .then . Then then again. Just in case you didn't know a way to do this. Done Oh wow. We just noticed we got column sorting for free with the default column metadata. The upshot \u00b6 Vehicles.tsx so far is import React , { useEffect , createRef } from 'react' ; import { Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { DataStore , SubscriptionMessage , ModelPredicate } from '@aws-amplify/datastore' ; import MaterialTable , { Column , Query , QueryResult , MaterialTableProps , Options } from 'material-table' const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" , emptyValue : '' }, ]; function Vehicles() { const tableRef = createRef < MaterialTableProps < Vehicle >> (); useEffect (() => { function subscriber ( msg : SubscriptionMessage < Vehicle > ) { console . log ( 'subscription' , msg . opType ); if ( tableRef . current ) { const table = tableRef . current ; if ( table . onQueryChange ) { table . onQueryChange ({ filters : [], orderBy : {}, orderDirection : 'asc' , page : table.page || 0 , pageSize : table.options?.pageSize || 5 , search : table.options?.searchText || '' }); } } }; const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, [ tableRef ]); function rowMapper ( vehicles : Vehicle []) : Vehicle [] { return vehicles . map ( vehicle => { return { ... vehicle } }); } function data ( query : Query < Vehicle > ) : Promise < QueryResult < Vehicle >> { return new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; function searchCriteria ( predicate : ModelPredicate < Vehicle > ) : ModelPredicate < Vehicle > { return predicate . or ( or => or . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search ) . mileage ( \"ge\" , parseInt ( query . search , 10 ))); } DataStore . query ( Vehicle , searchCriteria , thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }); }) . catch ( reject ); }) } const onRowAdd = ( newData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { const add = new Vehicle ({ make : newData.make , model : newData.model , mileage : parseInt ( newData . mileage , 10 ) }); DataStore . save ( add ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const onRowDelete = ( oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . delete ( Vehicle , oldData . id ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const onRowUpdate = ( newData : any , oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . query ( Vehicle , oldData . id ) . then ( original => { const updated = Vehicle . copyOf ( original , updated => { updated . make = newData . make updated . model = newData . model updated . mileage = parseInt ( newData . mileage , 10 ) }); return DataStore . save ( updated ); }) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , onRowDelete , onRowUpdate } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } > < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } /> < /Grid> < /Grid> ); } export default Vehicles ;","title":"Material Table"},{"location":"awesome-table/#start-simple","text":"Let's hook up Material Table to the existing data. Add the dependency yarn add material-table Import it. import MaterialTable from 'material-table' There's a ton of options for each column so we use the type Column to leverage editor completion. Always nice. numeric aligns right. And define some column metadata. import MaterialTable , { Column } from 'material-table' ; const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" }, ]; Now we have everything we need to replace our old table with the nice one. return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < MaterialTable data = { vehicles } columns = { columns } /> < /Grid> < /Grid> ); Try it. Ugh. We broke something and the page is blank. Material Table requires a mutable id on each row. AWS Amplify provides a different id , but it's readonly . So things won't work if you just pass a Vehicle around for rows. A quick fix is map each Vehicle to an untyped object. I found this out and figured out the fix so you don't have to. The function rowMapper(...) does this. function rowMapper ( vehicles : Vehicle []) : Vehicle [] { return vehicles . map ( vehicle => { return { ... vehicle } }); } Now <MaterialTable> looks like return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < MaterialTable data = { rowMapper ( vehicles )} columns = { columns } /> < /Grid> < /Grid> ); Try it again. Ugh. Although Material Table is already looking promising, it looks like we need some icons. Follow the instructions in https://material-table.com/#/docs/install . Yay. This table's looking properly amazing. Search works for string and numeric fields.","title":"Start simple"},{"location":"awesome-table/#but-of-course-were-not-stopping-here","text":"We're not, because this is a tutorial on Material Table and how to integrate with AWS Amplify. There's still lots to do before we're awesome. Try pressing the \"ADD VEHICLE\" button. See the total increase? Cool. Press it 1,000 more times. It slows down. A lot. Retrieving all the vehicles every time clearly doesn't work. Not so cool. Let's paginate. But first\u2014in a bold move bordering on reckless\u2014remove the vehicles state and the fetchAll() function. Comment it out in subscriber() . We're going need something here, and this will remind us. function Vehicles() now starts function Vehicles() { useEffect (() => { function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); // fetchAll(); } const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, []); function addVehicle() { ... The data property in <MaterialTable ... /> can also take a function instead of a simple array. Fields in the function argument, the query, allow us to retrieve just the right single page of vehicles, solving the fetch-everything-at-once ugliness. We'll take query.page and query.pageSize and call DataStore.query() to get just the right page. Oh, and data needs a Promise now. Oh, and DataStore.query() needs a predicate now, even the always-true predicate. import MaterialTable , { Column , Query , QueryResult } from 'material-table' ; function data ( query : Query < Vehicle > ) : Promise < QueryResult < Vehicle >> { return new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; DataStore . query ( Vehicle , Predicates . ALL , thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }); }) . catch ( reject ); }) }","title":"But of course we're not stopping here"},{"location":"awesome-table/#we-broke-some-things","text":"Only first page is displayed. And we don't refresh when we add a vehicle. (You might have noticed we set totalCount to a large number to get something going until we solve this.) There are a couple of reasons for this. For pagination to work correctly, Material Table needs to know the total number of rows. That used to be easy because we had all the rows. But now we only have a page at a time. Harder than you think It's because we're using GraphQL backed by DynamoDB. DynamoDB does not work like SQL where you can SELECT COUNT(*) ... or something. There's no way to get the total number without scanning a whole table, which is prohibitively expensive for large tables. We're going to solve this another way. But fair warning, this is going to feel like we don't know what we're doing.","title":"We broke some things"},{"location":"awesome-table/#search-is-broken-now-too","text":"It looks like there's a bad interaction between what we're now doing in Material Table and how we're using Amplify DataStore to fetch a page. Let's fix it. DataStore.query(...) takes a predicate, specifically a function that takes a ModelPredicate<Vehicle> and returns one too. Our task is to add some criteria to this predicate. We can take query.search and create criteria. Start with the make field in vehicle. function data ( query : Query < Vehicle > ) : Promise < QueryResult < Vehicle >> { return new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; function searchCriteria ( predicate : ModelPredicate < Vehicle > ) : ModelPredicate < Vehicle > { return predicate . make ( \"contains\" , query . search ); } DataStore . query ( Vehicle , searchCriteria , thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }); }) . catch ( reject ); }) } Now we can type a search term and get matching vehicle makes. Nice. Compound criteria are constructed like this predicate . make ( \"contains\" , query . search ). model ( \"contains\" , query . search ) but when we try it we discover that is an and criterion. We need or . This is the right incantation for that. function searchCriteria ( predicate : ModelPredicate < Vehicle > ) : ModelPredicate < Vehicle > { return predicate . or ( or => or . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search )); } Adding search on mileage is easy too: We just have to think of a reasonable semantics. \"Is greater than or equal\" is probably better than \"contains these digits.\" Now we have function searchCriteria ( predicate : ModelPredicate < Vehicle > ) : ModelPredicate < Vehicle > { return predicate . or ( or => or . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search ) . mileage ( \"ge\" , parseInt ( query . search , 10 ))); } Search is fixed. And the \u2265 semantics for mileage looks like a good call. We see there's a default title that's not very useful. Let's leave all the polish like this until after everything's working.","title":"Search is broken now too"},{"location":"awesome-table/#triggering-refresh","text":"We can add vehicles as before, but they're not showing up in the table. We need to connect the subscription to the table. It's pretty easy if you know how. We need to add a reference to the table so we can use to trigger a refresh. import React , { useEffect , createRef } from 'react' ; import MaterialTable , { Column , Query , QueryResult , MaterialTableProps } from 'material-table' const tableRef = createRef < MaterialTableProps < Vehicle >> (); Now bind it to the table like this. < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } /> Now all we have to do to trigger a refresh on the table when we get an event from the subscription. It's a bit finicky. We going to trip the table's onQueryChange() hook. That function requires some arguments, which we mostly relay from the current table state. There are a couple of things we didn't figure out how to get like the current orderBy . Irksome, but not a deal-breaker. Ever wonder what that empty [] was in the useEffect() hook declaration? Well it's for passing dependencies. tableRef is a dependency.","title":"Triggering refresh"},{"location":"awesome-table/#the-new-useeffect","text":"useEffect (() => { function subscriber ( msg : SubscriptionMessage < Vehicle > ) { console . log ( 'subscription' , msg . opType ); if ( tableRef . current ) { const table = tableRef . current ; if ( table . onQueryChange ) { table . onQueryChange ({ filters : [], orderBy : {}, orderDirection : 'asc' , page : table.page || 0 , pageSize : table.options?.pageSize || 5 , search : table.options?.searchText || '' }); } } }; const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, [ tableRef ]); Try it. Much better. Remember that if you want to delete all existing vehicles and start adding new one, you can add a <Button> and call DataStore . Like this < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < Button onClick = { onDeleteAll } > Delete all < /Button> < /Grid> function onDeleteAll ( event : React.MouseEvent ) { DataStore . delete ( Vehicle , Predicates . ALL ) . then ( console . log ) . catch ( console . error ) event . preventDefault (); } But the bloom is off the rose whe we ca see just how much we're redrawing of the table. We'll see if we can fix that later when we polish.","title":"The new useEffect"},{"location":"awesome-table/#manipulating-items-from-the-table-itself","text":"Note If you want to skip the details of making rows editable, fast-forward to The upshot . It's quite a bit of faffing about for here. The \"ADD VEHICLE\" button has a bunch of issues. Let's move that functionality to the table. Removing buttons simplifies the layout. return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } > < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } /> < /Grid> < /Grid> ); Material Table provides hooks for CRUD operations right in the table. The hooks are defined as editable ?: { isEditable ?: ( rowData : RowData ) => boolean ; isDeletable ?: ( rowData : RowData ) => boolean ; onRowAdd ?: ( newData : RowData ) => Promise < any > ; onRowUpdate ?: ( newData : RowData , oldData? : RowData ) => Promise < any > ; onRowDelete ?: ( oldData : RowData ) => Promise < any > ; } Let's add them one-by-one. We can start with no hooks because all hooks are optional. const editable = { }; < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } /> Test it. Nothing does nothing successfully. Before we can edit a row that has optional fields\u2014our mileage field\u2014we need to define a value returned when omitted. This is easy: Just add it to the Column . const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" , emptyValue : '' }, ];","title":"Manipulating items from the table itself"},{"location":"awesome-table/#adding-a-row","text":"Add a function to edit a row. We get save and cancel buttons for free. const onRowAdd = ( newData : Vehicle ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { const add = new Vehicle ({ make : newData.make , model : newData.model , mileage : newData.mileage }); DataStore . save ( add ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , } Let's unpack this. onRowAdd returns a Promise . That's easy: we just have to call resolve or reject like we already know. We create a new Vehicle with the fields setTimeout(() => {...}) returns a Timeout (1000ms feels right.) We call clearTimeout() only if the save succeeds. Otherwise it's standard Promise handling.","title":"Adding a row"},{"location":"awesome-table/#now-enable-deleting-a-row","text":"The function for onRowDelete looks very similar to that for onRowAdd . const onRowDelete = ( oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . delete ( Vehicle , oldData . id ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , onRowDelete , } Try it. Yay, a rubbish bin. Still noticing quite a bit of table flash.","title":"Now enable deleting a row"},{"location":"awesome-table/#updating-a-row","text":"const onRowUpdate = ( newData : any , oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . query ( Vehicle , oldData . id ) . then ( original => { const updated = Vehicle . copyOf ( original , updated => { updated . make = newData . make updated . model = newData . model updated . mileage = parseInt ( newData . mileage , 10 ) }); return DataStore . save ( updated ); }) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) The last one's a bit sneaky. It's chaining Promise s by returning a Promise from the first .then . Then then again. Just in case you didn't know a way to do this. Done Oh wow. We just noticed we got column sorting for free with the default column metadata.","title":"Updating a row"},{"location":"awesome-table/#the-upshot","text":"Vehicles.tsx so far is import React , { useEffect , createRef } from 'react' ; import { Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { DataStore , SubscriptionMessage , ModelPredicate } from '@aws-amplify/datastore' ; import MaterialTable , { Column , Query , QueryResult , MaterialTableProps , Options } from 'material-table' const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" , emptyValue : '' }, ]; function Vehicles() { const tableRef = createRef < MaterialTableProps < Vehicle >> (); useEffect (() => { function subscriber ( msg : SubscriptionMessage < Vehicle > ) { console . log ( 'subscription' , msg . opType ); if ( tableRef . current ) { const table = tableRef . current ; if ( table . onQueryChange ) { table . onQueryChange ({ filters : [], orderBy : {}, orderDirection : 'asc' , page : table.page || 0 , pageSize : table.options?.pageSize || 5 , search : table.options?.searchText || '' }); } } }; const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, [ tableRef ]); function rowMapper ( vehicles : Vehicle []) : Vehicle [] { return vehicles . map ( vehicle => { return { ... vehicle } }); } function data ( query : Query < Vehicle > ) : Promise < QueryResult < Vehicle >> { return new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; function searchCriteria ( predicate : ModelPredicate < Vehicle > ) : ModelPredicate < Vehicle > { return predicate . or ( or => or . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search ) . mileage ( \"ge\" , parseInt ( query . search , 10 ))); } DataStore . query ( Vehicle , searchCriteria , thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }); }) . catch ( reject ); }) } const onRowAdd = ( newData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { const add = new Vehicle ({ make : newData.make , model : newData.model , mileage : parseInt ( newData . mileage , 10 ) }); DataStore . save ( add ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const onRowDelete = ( oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . delete ( Vehicle , oldData . id ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const onRowUpdate = ( newData : any , oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . query ( Vehicle , oldData . id ) . then ( original => { const updated = Vehicle . copyOf ( original , updated => { updated . make = newData . make updated . model = newData . model updated . mileage = parseInt ( newData . mileage , 10 ) }); return DataStore . save ( updated ); }) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , onRowDelete , onRowUpdate } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } > < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } /> < /Grid> < /Grid> ); } export default Vehicles ;","title":"The upshot"},{"location":"connecttobackend/","text":"Where should we put this? What are the responses? amplify update api amplify push Note We're going to keep the state as-is for now. You'll see that the way we use it is inefficient because we're fetching all vehicles every time we make a change. The basic table provided by React Material does not provide pagination with lazy loading. We'll get to a solution for this in a bit. But it's a bit complicated and might throw us off the scent if we do that now. If you're curious, we're going to show you how to use Material Table, https://material-table.com for lots of table goodness. If you're sharp-eyed, you notice Amplify created configuration in aws-exports.js , which contains something like. // WARNING: DO NOT EDIT. This file is automatically generated by AWS Amplify. It will be overwritten. const awsmobile = { \"aws_project_region\" : \"us-east-1\" , \"aws_appsync_graphqlEndpoint\" : \"https://xxx.appsync-api.us-east-1.amazonaws.com/graphql\" , \"aws_appsync_region\" : \"us-east-1\" , \"aws_appsync_authenticationType\" : \"API_KEY\" , \"aws_appsync_apiKey\" : \"xxx\" }; export default awsmobile ; Let Amplify maintain this file just like it says. Initialize Amplify \u00b6 We need to import and initialize Amplify with the configuration in awsmobile . We only need to do it once, so let's put it in index.tsx . This goes in index.tsx . import Amplify from '@aws-amplify/core' ; import amplify_configuration from './aws-exports' ; Amplify . configure ( amplify_configuration ); Use the DataStore API in Vehicles.tsx \u00b6 The DataStore API is an alternative to using the raw GraphQL API, which can get a bit fiddly to get right at first. This goes in Vehicles.tsx . Using DataStore \u00b6 Import it. import { DataStore } from '@aws-amplify/datastore' ; DataStore functions return Promise s. So we have to handle that in addVehicle() where we save a vehicle, now using DataStore.save() . function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); DataStore . save ( vehicle ) . then ( console . log ) . catch ( console . error ); } That's also true for DataStore.query() , the way we're going to fetch data now. Note The default query is all objects. We can supply predicates and pagination details in the query. We'll get to that when we use https://material-table.com/#/ , which lazy loads as it paginates. We use the setVehicles(...) React hook as before. But this time with the results of the DataStore query. Here's that function. function fetchAll() { DataStore . query ( Vehicle ) . then ( setVehicles ) . catch ( console . error ); }; Handle subscription events \u00b6 We're going to subscribe to changes in the back-end data and reload all the vehicles every time we get an event. This is AWS AppSync at work. See https://docs.aws.amazon.com/appsync/index.html . This function is handy for tracking events as we get them. import { DataStore , SubscriptionMessage } from '@aws-amplify/datastore' ; ... function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); fetchAll (); } Observe changes and subscribe to them \u00b6 Now that we have a functions fetchAll() and subscriber() , let's put them together in a withEffect() . Read that as \"with side-effect\". You can find out more here: https://reactjs.org/docs/hooks-effect.html . import React , { useEffect } from 'react' ; useEffect (() => { fetchAll (); function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); fetchAll (); } const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, []); Now whenever AppSync sends us an update we read the data from DynamoDB and display it. So now we have What How <Button> click handler onClick() on <Button> definition Adding a (random) vehicle addVehicle() in onClick() , which calls the DataStore to save the new vehicle. A subscription event handler subscriber() A subscriber to changes in the Vehicle database In useEffect() Note I guarantee this all seems totally useless and unnecessary at the moment. Just wait. Prepare to be astounded. Let's try it anyway. ( yarn start as usual.) Now for the astonishing bit \u00b6 Open up another browser http://localhost:3000 and watch what happens when you add a vehicle. You just wrote Google docs for cars. The upshot \u00b6 We configured Amplify. We created an Amplify DataSource observer and subscribed to events from it. We learned just a little about useEffect() and glued that all together. We were a bit astonished at what that allowed us to do if we're being honest. The final index.tsx is import React from 'react' ; import ReactDOM from 'react-dom' ; import './index.css' ; import App from './App' ; import * as serviceWorker from './serviceWorker' ; import { createMuiTheme , ThemeProvider , CssBaseline } from '@material-ui/core' ; import { BrowserRouter } from \"react-router-dom\" ; import Amplify from \"aws-amplify\" ; import awsExports from \"./aws-exports\" ; Amplify . configure ( awsExports ); const theme = createMuiTheme ({ palette : { type : 'dark' , }, }); ReactDOM . render ( < React . StrictMode > < ThemeProvider theme = { theme } > < CssBaseline /> < BrowserRouter > < App /> < /BrowserRouter> < /ThemeProvider> < /React.StrictMode>, document . getElementById ( 'root' ) ); // If you want your app to work offline and load faster, you can change // unregister() to register() below. Note this comes with some pitfalls. // Learn more about service workers: https://bit.ly/CRA-PWA serviceWorker . unregister (); The final Vehicles.tsx is import React , { useEffect } from 'react' ; import { Button , Table , TableHead , TableRow , TableCell , TableBody , Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { uuid } from 'uuidv4' ; import { DataStore , SubscriptionMessage } from '@aws-amplify/datastore' ; function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function fetchAll() { DataStore . query ( Vehicle ) . then ( setVehicles ) . catch ( console . error ); }; useEffect (() => { fetchAll (); function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); fetchAll (); } const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, []); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); DataStore . save ( vehicle ) . then ( console . log ) . catch ( console . error ); } function onClick ( event : React.MouseEvent ) { addVehicle (); event . preventDefault (); } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < Table > < TableHead > < TableRow > < TableCell > Make < /TableCell> < TableCell > Model < /TableCell> < TableCell > Mileage < /TableCell> < /TableRow> < /TableHead> < TableBody > { vehicles . map (( vehicle ) => ( < TableRow > < TableCell > { vehicle . make } < /TableCell> < TableCell > { vehicle . model } < /TableCell> < TableCell align = \"right\" > { vehicle . mileage } < /TableCell> < /TableRow> )) } < /TableBody> < /Table> < /Grid> < /Grid> ); } export default Vehicles ;","title":"Connect to the back-end"},{"location":"connecttobackend/#initialize-amplify","text":"We need to import and initialize Amplify with the configuration in awsmobile . We only need to do it once, so let's put it in index.tsx . This goes in index.tsx . import Amplify from '@aws-amplify/core' ; import amplify_configuration from './aws-exports' ; Amplify . configure ( amplify_configuration );","title":"Initialize Amplify"},{"location":"connecttobackend/#use-the-datastore-api-in-vehiclestsx","text":"The DataStore API is an alternative to using the raw GraphQL API, which can get a bit fiddly to get right at first. This goes in Vehicles.tsx .","title":"Use the DataStore API in Vehicles.tsx"},{"location":"connecttobackend/#using-datastore","text":"Import it. import { DataStore } from '@aws-amplify/datastore' ; DataStore functions return Promise s. So we have to handle that in addVehicle() where we save a vehicle, now using DataStore.save() . function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); DataStore . save ( vehicle ) . then ( console . log ) . catch ( console . error ); } That's also true for DataStore.query() , the way we're going to fetch data now. Note The default query is all objects. We can supply predicates and pagination details in the query. We'll get to that when we use https://material-table.com/#/ , which lazy loads as it paginates. We use the setVehicles(...) React hook as before. But this time with the results of the DataStore query. Here's that function. function fetchAll() { DataStore . query ( Vehicle ) . then ( setVehicles ) . catch ( console . error ); };","title":"Using DataStore"},{"location":"connecttobackend/#handle-subscription-events","text":"We're going to subscribe to changes in the back-end data and reload all the vehicles every time we get an event. This is AWS AppSync at work. See https://docs.aws.amazon.com/appsync/index.html . This function is handy for tracking events as we get them. import { DataStore , SubscriptionMessage } from '@aws-amplify/datastore' ; ... function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); fetchAll (); }","title":"Handle subscription events"},{"location":"connecttobackend/#observe-changes-and-subscribe-to-them","text":"Now that we have a functions fetchAll() and subscriber() , let's put them together in a withEffect() . Read that as \"with side-effect\". You can find out more here: https://reactjs.org/docs/hooks-effect.html . import React , { useEffect } from 'react' ; useEffect (() => { fetchAll (); function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); fetchAll (); } const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, []); Now whenever AppSync sends us an update we read the data from DynamoDB and display it. So now we have What How <Button> click handler onClick() on <Button> definition Adding a (random) vehicle addVehicle() in onClick() , which calls the DataStore to save the new vehicle. A subscription event handler subscriber() A subscriber to changes in the Vehicle database In useEffect() Note I guarantee this all seems totally useless and unnecessary at the moment. Just wait. Prepare to be astounded. Let's try it anyway. ( yarn start as usual.)","title":"Observe changes and subscribe to them"},{"location":"connecttobackend/#now-for-the-astonishing-bit","text":"Open up another browser http://localhost:3000 and watch what happens when you add a vehicle. You just wrote Google docs for cars.","title":"Now for the astonishing bit"},{"location":"connecttobackend/#the-upshot","text":"We configured Amplify. We created an Amplify DataSource observer and subscribed to events from it. We learned just a little about useEffect() and glued that all together. We were a bit astonished at what that allowed us to do if we're being honest. The final index.tsx is import React from 'react' ; import ReactDOM from 'react-dom' ; import './index.css' ; import App from './App' ; import * as serviceWorker from './serviceWorker' ; import { createMuiTheme , ThemeProvider , CssBaseline } from '@material-ui/core' ; import { BrowserRouter } from \"react-router-dom\" ; import Amplify from \"aws-amplify\" ; import awsExports from \"./aws-exports\" ; Amplify . configure ( awsExports ); const theme = createMuiTheme ({ palette : { type : 'dark' , }, }); ReactDOM . render ( < React . StrictMode > < ThemeProvider theme = { theme } > < CssBaseline /> < BrowserRouter > < App /> < /BrowserRouter> < /ThemeProvider> < /React.StrictMode>, document . getElementById ( 'root' ) ); // If you want your app to work offline and load faster, you can change // unregister() to register() below. Note this comes with some pitfalls. // Learn more about service workers: https://bit.ly/CRA-PWA serviceWorker . unregister (); The final Vehicles.tsx is import React , { useEffect } from 'react' ; import { Button , Table , TableHead , TableRow , TableCell , TableBody , Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { uuid } from 'uuidv4' ; import { DataStore , SubscriptionMessage } from '@aws-amplify/datastore' ; function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function fetchAll() { DataStore . query ( Vehicle ) . then ( setVehicles ) . catch ( console . error ); }; useEffect (() => { fetchAll (); function subscriber ( subscriptionMessage : SubscriptionMessage < Vehicle > ) { console . log ( 'subscriptionMessage' , subscriptionMessage ); fetchAll (); } const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, []); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); DataStore . save ( vehicle ) . then ( console . log ) . catch ( console . error ); } function onClick ( event : React.MouseEvent ) { addVehicle (); event . preventDefault (); } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } sm = { 3 } > < Button onClick = { onClick } > Add vehicle < /Button> < /Grid> < Grid item xs = { 12 } sm = { 9 } > < Table > < TableHead > < TableRow > < TableCell > Make < /TableCell> < TableCell > Model < /TableCell> < TableCell > Mileage < /TableCell> < /TableRow> < /TableHead> < TableBody > { vehicles . map (( vehicle ) => ( < TableRow > < TableCell > { vehicle . make } < /TableCell> < TableCell > { vehicle . model } < /TableCell> < TableCell align = \"right\" > { vehicle . mileage } < /TableCell> < /TableRow> )) } < /TableBody> < /Table> < /Grid> < /Grid> ); } export default Vehicles ;","title":"The upshot"},{"location":"createproject/","text":"yarn create react-app c-19-autobody --template typescript cd c-19-autobody yarn start The upshot \u00b6 Your basic TypeScript React App.","title":"Create the project"},{"location":"createproject/#the-upshot","text":"Your basic TypeScript React App.","title":"The upshot"},{"location":"license/","text":"MIT License Copyright \u00a9 2020 Stephen Harrison Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"material/","text":"Get React Material UI \u00b6 yarn add @material-ui/core A trivial page with a toolbar \u00b6 Replace App.tsx with this import React from 'react'; import { AppBar, Toolbar, Typography } from '@material-ui/core'; function App() { return ( <AppBar color=\"inherit\" position=\"static\"> <Toolbar> <Typography variant=\"h4\" >Welcome to C-19 Autobody</Typography> </Toolbar> </AppBar> ); } export default App; Do you like dark theme? \u00b6 If you like your Material theme dark, change your index.tsx to import React from 'react'; import ReactDOM from 'react-dom'; import './index.css'; import App from './App'; import * as serviceWorker from './serviceWorker'; import { createMuiTheme, ThemeProvider, CssBaseline } from '@material-ui/core'; const theme = createMuiTheme({ palette: { type: 'dark', }, }); ReactDOM.render( <React.StrictMode> <ThemeProvider theme={theme}> <CssBaseline /> <App /> </ThemeProvider> </React.StrictMode>, document.getElementById('root') ); // If you want your app to work offline and load faster, you can change // unregister() to register() below. Note this comes with some pitfalls. // Learn more about service workers: https://bit.ly/CRA-PWA serviceWorker.unregister(); We like dark theme. The upshot \u00b6","title":"Add React Material"},{"location":"material/#get-react-material-ui","text":"yarn add @material-ui/core","title":"Get React Material UI"},{"location":"material/#a-trivial-page-with-a-toolbar","text":"Replace App.tsx with this import React from 'react'; import { AppBar, Toolbar, Typography } from '@material-ui/core'; function App() { return ( <AppBar color=\"inherit\" position=\"static\"> <Toolbar> <Typography variant=\"h4\" >Welcome to C-19 Autobody</Typography> </Toolbar> </AppBar> ); } export default App;","title":"A trivial page with a toolbar"},{"location":"material/#do-you-like-dark-theme","text":"If you like your Material theme dark, change your index.tsx to import React from 'react'; import ReactDOM from 'react-dom'; import './index.css'; import App from './App'; import * as serviceWorker from './serviceWorker'; import { createMuiTheme, ThemeProvider, CssBaseline } from '@material-ui/core'; const theme = createMuiTheme({ palette: { type: 'dark', }, }); ReactDOM.render( <React.StrictMode> <ThemeProvider theme={theme}> <CssBaseline /> <App /> </ThemeProvider> </React.StrictMode>, document.getElementById('root') ); // If you want your app to work offline and load faster, you can change // unregister() to register() below. Note this comes with some pitfalls. // Learn more about service workers: https://bit.ly/CRA-PWA serviceWorker.unregister(); We like dark theme.","title":"Do you like dark theme?"},{"location":"material/#the-upshot","text":"","title":"The upshot"},{"location":"navigation/","text":"Info If you get turned around with the sequence of updates we're going to make with files, or if you'd rather the TL;DR, click \"The upshot\" on the right to see what's what. Well, first we need to be able to get to pages for all the things you'll be dealing with in an autobody shop: vehicles , owners , services , parts , and work orders . Let's set up a row of buttons for that. They won't be plugged in yet. We'll get to that shortly. Replace App.tsx with import React from 'react' ; import { AppBar , Toolbar , Typography , Button } from '@material-ui/core' ; function App() { return ( <> < AppBar color = \"inherit\" position = \"static\" > < Toolbar > < Typography variant = \"h4\" > Welcome to C - 19 Autobody < /Typography> < /Toolbar> < div > < Button > Home < /Button> < Button > Vehicles < /Button> < Button > Owners < /Button> < Button > Services < /Button> < Button > Parts < /Button> < Button > Work Orders < /Button> < /div> < /AppBar> < /> ); } export default App ; Try it. Getting better. We can argue about spacing later. The out-of-the-box spacing is at least not completely wrong. Create stubs for all the components \u00b6 For the Home component, simply add the file Home.tsx in the src directory with the content below. We're going to add routing to these in bit. import React from 'react' ; import { Typography } from '@material-ui/core' ; function Home() { return ( <> < Typography variant = \"h3\" > Home < /Typography> < Typography variant = \"body1\" > The is a work - in - progress React Material and AWS Amplify application . Click the \"Vehicles\" tab to see what it ' s about . < /Typography> < /> ); } export default Home ; Now create Vehicles.tsx . import React from 'react' ; import { Typography } from '@material-ui/core' ; function Vehicles() { return ( < Typography variant = \"h3\" > Vehicles < /Typography> ); } export default Vehicles ; And Placeholder.tsx import React from 'react' ; import { Typography } from '@material-ui/core' ; function Placeholder() { return ( < Typography variant = \"h3\" > Placeholder < /Typography> ); } export default Placeholder ; Now we're ready to add routing to those components. We call out Vehicles.tsx separately because that's the component we're going to work on first. Add routes to those stubs \u00b6 First add the react-router-dom dependency and TypeScript definitions. yarn add react-router-dom @types/react-router-dom Now wrap the App component in a <BrowserRouter> ... </BrowserRouter> . The easiest place to do this is in index.tsx . Make these changes in index.tsx . Add the import import { BrowserRouter } from \"react-router-dom\" ; And then wrap the existing <App /> like this ReactDOM . render ( < React . StrictMode > < ThemeProvider theme = { theme } > < CssBaseline /> < BrowserRouter > < App /> < /BrowserRouter> < /ThemeProvider> < /React.StrictMode>, document . getElementById ( 'root' ) ); Add some actual routing \u00b6 It's actually pretty easy now we have the stub components and the <BrowserRouter> wrapper. Make these changes in App.tsx . Add <Link> s and URL paths to the <Button> s in the <AppBar> . < div > < Link to = \"/\" component = { Button } > Home < /Link> < Link to = \"/vehicles\" component = { Button } > Vehicles < /Link> < Link to = \"/owners\" component = { Button } > Owners < /Link> < Link to = \"/services\" component = { Button } > Services < /Link> < Link to = \"/parts\" component = { Button } > Parts < /Link> < Link to = \"/workorders\" component = { Button } > Work Orders < /Link> < /div> Now add a dispatcher for the URL paths to the corresponding components. import { Route , Switch , Link } from 'react-router-dom' import Placeholder from './Placeholder' ; import Home from './Home' ; import Vehicles from './Vehicles' ; < main > < Switch > < Route path = \"/\" component = { Home } exact /> < Route path = \"/vehicles\" component = { Vehicles } /> < Route path = \"/owners\" component = { Owners } /> < Route path = \"/services\" component = { Services } /> < Route path = \"/parts\" component = { Parts } /> < Route path = \"/workorders\" component = { WorkOrders } /> < /Switch> < /main> Try it with yarn start as usual. Warning We know. It looks dreadful right now. We're going to clean it up in a bit. The upshot \u00b6 After all our changes, here's where we ended up. index.tsx is import React from 'react' ; import ReactDOM from 'react-dom' ; import './index.css' ; import App from './App' ; import * as serviceWorker from './serviceWorker' ; import { createMuiTheme , ThemeProvider , CssBaseline } from '@material-ui/core' ; import { BrowserRouter } from \"react-router-dom\" ; const theme = createMuiTheme ({ palette : { type : 'dark' , }, }); ReactDOM . render ( < React . StrictMode > < ThemeProvider theme = { theme } > < CssBaseline /> < BrowserRouter > < App /> < /BrowserRouter> < /ThemeProvider> < /React.StrictMode>, document . getElementById ( 'root' ) ); // If you want your app to work offline and load faster, you can change // unregister() to register() below. Note this comes with some pitfalls. // Learn more about service workers: https://bit.ly/CRA-PWA serviceWorker . unregister (); App.tsx is import React from 'react' ; import { AppBar , Toolbar , Typography , Button } from '@material-ui/core' ; import { Link , Route , Switch } from 'react-router-dom' ; import Home from './Home' ; import Vehicles from './Vehicles' ; import Placeholder from './Placeholder' ; function App() { return ( <> < AppBar color = \"inherit\" position = \"static\" > < Toolbar > < Typography variant = \"h4\" > Welcome to C - 19 Autobody < /Typography> < /Toolbar> < div > < Link to = \"/\" component = { Button } > Home < /Link> < Link to = \"/vehicles\" component = { Button } > Vehicles < /Link> < Link to = \"/owners\" component = { Button } > Owners < /Link> < Link to = \"/services\" component = { Button } > Services < /Link> < Link to = \"/parts\" component = { Button } > Parts < /Link> < Link to = \"/workorders\" component = { Button } > Work Orders < /Link> < /div> < /AppBar> < div > < main > < Switch > < Route path = \"/\" component = { Home } exact /> < Route path = \"/vehicles\" component = { Vehicles } /> < Route path = \"/owners\" component = { Placeholder } /> < Route path = \"/services\" component = { Placeholder } /> < Route path = \"/parts\" component = { Placeholder } /> < Route path = \"/workorders\" component = { Placeholder } /> < /Switch> < /main> < /div> < /> ); } export default App ; As we pointed out above, it's not going to win any design awards. Keep going anyway just in case we fix it.","title":"Add navigation"},{"location":"navigation/#create-stubs-for-all-the-components","text":"For the Home component, simply add the file Home.tsx in the src directory with the content below. We're going to add routing to these in bit. import React from 'react' ; import { Typography } from '@material-ui/core' ; function Home() { return ( <> < Typography variant = \"h3\" > Home < /Typography> < Typography variant = \"body1\" > The is a work - in - progress React Material and AWS Amplify application . Click the \"Vehicles\" tab to see what it ' s about . < /Typography> < /> ); } export default Home ; Now create Vehicles.tsx . import React from 'react' ; import { Typography } from '@material-ui/core' ; function Vehicles() { return ( < Typography variant = \"h3\" > Vehicles < /Typography> ); } export default Vehicles ; And Placeholder.tsx import React from 'react' ; import { Typography } from '@material-ui/core' ; function Placeholder() { return ( < Typography variant = \"h3\" > Placeholder < /Typography> ); } export default Placeholder ; Now we're ready to add routing to those components. We call out Vehicles.tsx separately because that's the component we're going to work on first.","title":"Create stubs for all the components"},{"location":"navigation/#add-routes-to-those-stubs","text":"First add the react-router-dom dependency and TypeScript definitions. yarn add react-router-dom @types/react-router-dom Now wrap the App component in a <BrowserRouter> ... </BrowserRouter> . The easiest place to do this is in index.tsx . Make these changes in index.tsx . Add the import import { BrowserRouter } from \"react-router-dom\" ; And then wrap the existing <App /> like this ReactDOM . render ( < React . StrictMode > < ThemeProvider theme = { theme } > < CssBaseline /> < BrowserRouter > < App /> < /BrowserRouter> < /ThemeProvider> < /React.StrictMode>, document . getElementById ( 'root' ) );","title":"Add routes to those stubs"},{"location":"navigation/#add-some-actual-routing","text":"It's actually pretty easy now we have the stub components and the <BrowserRouter> wrapper. Make these changes in App.tsx . Add <Link> s and URL paths to the <Button> s in the <AppBar> . < div > < Link to = \"/\" component = { Button } > Home < /Link> < Link to = \"/vehicles\" component = { Button } > Vehicles < /Link> < Link to = \"/owners\" component = { Button } > Owners < /Link> < Link to = \"/services\" component = { Button } > Services < /Link> < Link to = \"/parts\" component = { Button } > Parts < /Link> < Link to = \"/workorders\" component = { Button } > Work Orders < /Link> < /div> Now add a dispatcher for the URL paths to the corresponding components. import { Route , Switch , Link } from 'react-router-dom' import Placeholder from './Placeholder' ; import Home from './Home' ; import Vehicles from './Vehicles' ; < main > < Switch > < Route path = \"/\" component = { Home } exact /> < Route path = \"/vehicles\" component = { Vehicles } /> < Route path = \"/owners\" component = { Owners } /> < Route path = \"/services\" component = { Services } /> < Route path = \"/parts\" component = { Parts } /> < Route path = \"/workorders\" component = { WorkOrders } /> < /Switch> < /main> Try it with yarn start as usual. Warning We know. It looks dreadful right now. We're going to clean it up in a bit.","title":"Add some actual routing"},{"location":"navigation/#the-upshot","text":"After all our changes, here's where we ended up. index.tsx is import React from 'react' ; import ReactDOM from 'react-dom' ; import './index.css' ; import App from './App' ; import * as serviceWorker from './serviceWorker' ; import { createMuiTheme , ThemeProvider , CssBaseline } from '@material-ui/core' ; import { BrowserRouter } from \"react-router-dom\" ; const theme = createMuiTheme ({ palette : { type : 'dark' , }, }); ReactDOM . render ( < React . StrictMode > < ThemeProvider theme = { theme } > < CssBaseline /> < BrowserRouter > < App /> < /BrowserRouter> < /ThemeProvider> < /React.StrictMode>, document . getElementById ( 'root' ) ); // If you want your app to work offline and load faster, you can change // unregister() to register() below. Note this comes with some pitfalls. // Learn more about service workers: https://bit.ly/CRA-PWA serviceWorker . unregister (); App.tsx is import React from 'react' ; import { AppBar , Toolbar , Typography , Button } from '@material-ui/core' ; import { Link , Route , Switch } from 'react-router-dom' ; import Home from './Home' ; import Vehicles from './Vehicles' ; import Placeholder from './Placeholder' ; function App() { return ( <> < AppBar color = \"inherit\" position = \"static\" > < Toolbar > < Typography variant = \"h4\" > Welcome to C - 19 Autobody < /Typography> < /Toolbar> < div > < Link to = \"/\" component = { Button } > Home < /Link> < Link to = \"/vehicles\" component = { Button } > Vehicles < /Link> < Link to = \"/owners\" component = { Button } > Owners < /Link> < Link to = \"/services\" component = { Button } > Services < /Link> < Link to = \"/parts\" component = { Button } > Parts < /Link> < Link to = \"/workorders\" component = { Button } > Work Orders < /Link> < /div> < /AppBar> < div > < main > < Switch > < Route path = \"/\" component = { Home } exact /> < Route path = \"/vehicles\" component = { Vehicles } /> < Route path = \"/owners\" component = { Placeholder } /> < Route path = \"/services\" component = { Placeholder } /> < Route path = \"/parts\" component = { Placeholder } /> < Route path = \"/workorders\" component = { Placeholder } /> < /Switch> < /main> < /div> < /> ); } export default App ; As we pointed out above, it's not going to win any design awards. Keep going anyway just in case we fix it.","title":"The upshot"},{"location":"prepare-ui/","text":"We're going to add code to one of the pages\u2014vehicles\u2014to add a vehicle and list them out. We just generate random values for fields for now. And it won't be hooked up to the back end. But this will let us see how to update state and display the complete list. A little layout \u00b6 Lets solve the ugly indentation of the \"Vehicles\" header. Actually, let's solve the problem for all pages at the same time. This is easy: Just add a simple style to App.tsx . Define a style before the function definition like this. This goes in App.tsx . import { makeStyles } from '@material-ui/core' ; const useStyles = makeStyles (( theme ) => ({ content : { // top, right, bottom, left margin : theme.spacing ( 2 , 2 , 0 , 2 ) } })); The theme argument lets us use spacing from the theme itself. We could use hard-coded pixel sizes, but we'd have to update all those manually every time the theme changes. That would be not only annoying, but in addition your pull request would be rejected and no one on your team will want to go to lunch with you today. makeStyles() returns a function. We get the classNames from the result of calling this function. And we use it referencing the class name. Look at the <div> around the <Switch> . function App() { const classes = useStyles (); return ( <> < AppBar color = \"inherit\" position = \"static\" > < Toolbar > < Typography variant = \"h4\" > Welcome to C - 19 Autobody < /Typography> < /Toolbar> < div > < Link to = \"/\" component = { Button } > Home < /Link> ... < /div> < /AppBar> < div className = { classes . content } > < main > < Switch > < Route path = \"/\" component = { Home } exact /> ... < /Switch> < /main> < /div> < /> ); } It's looking quite a bit better. We have every right to be chuffed. Generate GraphQL models \u00b6 We defined a model for a vehicle in the previous chapter. type Vehicle @model { id: ID! make: String! model: String! mileage: Int } Now generate TypeScript type definitions. amplify codegen models In case you're wondering, this is what's generated. import { ModelInit , MutableModel , PersistentModelConstructor } from \"@aws-amplify/datastore\" ; export declare class Vehicle { readonly id : string ; readonly make : string ; readonly model : string ; readonly mileage? : number ; constructor ( init : ModelInit < Vehicle > ); static copyOf ( source : Vehicle , mutator : ( draft : MutableModel < Vehicle > ) => MutableModel < Vehicle > | void ) : Vehicle ; } A bit of a mouthful, but it's going to be jolly useful. Specifically, we're going to use the Vehicle class intact. Now add some state for the list of vehicles \u00b6 All this goes in Vehicles.tsx . Import the new Vehicle class import { Vehicle } from './models' ; We maintain state using React hooks. See https://reactjs.org/docs/hooks-overview.html . Hooks are so cool. const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]) We'll be using random placeholders for fields: UUIDs are just the ticket. yarn add uuidv4 @types/uuid And import it import { uuid } from 'uuidv4' ; Code to update the list of vehicles \u00b6 A new function, addVehicle() , adds a vehicle to the vehicles state. function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); setVehicles ([... vehicles , vehicle ]); } Note The Vehicle class contains metadata that Amplify runtime uses for persistence. This is out-of-bounds for us to update directly. However all persistent classes derived from schema.graphql \u2014including our Vehicle class\u2014include a constructor with just our fields except id , which is considered part of the metadata. Add a <Button onClick{...}> handler. This also needs to be inside the main function. function onClick ( event : React.MouseEvent ) { console . log ( 'event' , event ); addVehicle (); event . preventDefault (); } The event.preventDefault(); is necessary because React decorates native DOM events and we don't want the browser to refresh or reload the window with the underlying event. Add a <Button> and wire up the onclick() handler, and replace the existing <Typography> element with some JSON. import { Typography , Button } from '@material-ui/core' ; return ( <> < Button onClick = { onClick } > Add vehicle < /Button> < Typography > { JSON . stringify ( vehicles )} < /Typography> < /> ); Try it out. Nice. Now there's a button \"ADD VEHICLE\" and some JSON for all the vehicles we're adding. The upshot \u00b6 We make a very primitive component that updates and displays state. Vehicles.tsx is now import React from 'react' ; import { Typography , Button } from '@material-ui/core' ; import { Vehicle } from './models' ; import { uuid } from 'uuidv4' ; function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); setVehicles ([... vehicles , vehicle ]); } function onClick ( event : React.MouseEvent ) { console . log ( 'event' , event ); addVehicle (); event . preventDefault (); } return ( <> < Button onClick = { onClick } > Add vehicle < /Button> < Typography > { JSON . stringify ( vehicles )} < /Typography> < /> ); } export default Vehicles ; Note If you have a keen eye, you'll see that the Amplify runtime has already created values for the id fields when new did new Vehicle({ make, model, mileage }) . This also happens to be a UUID. Just not one of the ones we assigned explicitly. This explanation's a bit confusing. Sorry about that.","title":"Prepare the UI"},{"location":"prepare-ui/#a-little-layout","text":"Lets solve the ugly indentation of the \"Vehicles\" header. Actually, let's solve the problem for all pages at the same time. This is easy: Just add a simple style to App.tsx . Define a style before the function definition like this. This goes in App.tsx . import { makeStyles } from '@material-ui/core' ; const useStyles = makeStyles (( theme ) => ({ content : { // top, right, bottom, left margin : theme.spacing ( 2 , 2 , 0 , 2 ) } })); The theme argument lets us use spacing from the theme itself. We could use hard-coded pixel sizes, but we'd have to update all those manually every time the theme changes. That would be not only annoying, but in addition your pull request would be rejected and no one on your team will want to go to lunch with you today. makeStyles() returns a function. We get the classNames from the result of calling this function. And we use it referencing the class name. Look at the <div> around the <Switch> . function App() { const classes = useStyles (); return ( <> < AppBar color = \"inherit\" position = \"static\" > < Toolbar > < Typography variant = \"h4\" > Welcome to C - 19 Autobody < /Typography> < /Toolbar> < div > < Link to = \"/\" component = { Button } > Home < /Link> ... < /div> < /AppBar> < div className = { classes . content } > < main > < Switch > < Route path = \"/\" component = { Home } exact /> ... < /Switch> < /main> < /div> < /> ); } It's looking quite a bit better. We have every right to be chuffed.","title":"A little layout"},{"location":"prepare-ui/#generate-graphql-models","text":"We defined a model for a vehicle in the previous chapter. type Vehicle @model { id: ID! make: String! model: String! mileage: Int } Now generate TypeScript type definitions. amplify codegen models In case you're wondering, this is what's generated. import { ModelInit , MutableModel , PersistentModelConstructor } from \"@aws-amplify/datastore\" ; export declare class Vehicle { readonly id : string ; readonly make : string ; readonly model : string ; readonly mileage? : number ; constructor ( init : ModelInit < Vehicle > ); static copyOf ( source : Vehicle , mutator : ( draft : MutableModel < Vehicle > ) => MutableModel < Vehicle > | void ) : Vehicle ; } A bit of a mouthful, but it's going to be jolly useful. Specifically, we're going to use the Vehicle class intact.","title":"Generate GraphQL models"},{"location":"prepare-ui/#now-add-some-state-for-the-list-of-vehicles","text":"All this goes in Vehicles.tsx . Import the new Vehicle class import { Vehicle } from './models' ; We maintain state using React hooks. See https://reactjs.org/docs/hooks-overview.html . Hooks are so cool. const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]) We'll be using random placeholders for fields: UUIDs are just the ticket. yarn add uuidv4 @types/uuid And import it import { uuid } from 'uuidv4' ;","title":"Now add some state for the list of vehicles"},{"location":"prepare-ui/#code-to-update-the-list-of-vehicles","text":"A new function, addVehicle() , adds a vehicle to the vehicles state. function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); setVehicles ([... vehicles , vehicle ]); } Note The Vehicle class contains metadata that Amplify runtime uses for persistence. This is out-of-bounds for us to update directly. However all persistent classes derived from schema.graphql \u2014including our Vehicle class\u2014include a constructor with just our fields except id , which is considered part of the metadata. Add a <Button onClick{...}> handler. This also needs to be inside the main function. function onClick ( event : React.MouseEvent ) { console . log ( 'event' , event ); addVehicle (); event . preventDefault (); } The event.preventDefault(); is necessary because React decorates native DOM events and we don't want the browser to refresh or reload the window with the underlying event. Add a <Button> and wire up the onclick() handler, and replace the existing <Typography> element with some JSON. import { Typography , Button } from '@material-ui/core' ; return ( <> < Button onClick = { onClick } > Add vehicle < /Button> < Typography > { JSON . stringify ( vehicles )} < /Typography> < /> ); Try it out. Nice. Now there's a button \"ADD VEHICLE\" and some JSON for all the vehicles we're adding.","title":"Code to update the list of vehicles"},{"location":"prepare-ui/#the-upshot","text":"We make a very primitive component that updates and displays state. Vehicles.tsx is now import React from 'react' ; import { Typography , Button } from '@material-ui/core' ; import { Vehicle } from './models' ; import { uuid } from 'uuidv4' ; function Vehicles() { const [ vehicles , setVehicles ] = React . useState < Vehicle [] > ([]); function addVehicle() { const make = uuid (); const model = uuid (); const mileage = Math . floor ( Math . random () * 100000 ) + 1 const vehicle = new Vehicle ({ make , model , mileage }); setVehicles ([... vehicles , vehicle ]); } function onClick ( event : React.MouseEvent ) { console . log ( 'event' , event ); addVehicle (); event . preventDefault (); } return ( <> < Button onClick = { onClick } > Add vehicle < /Button> < Typography > { JSON . stringify ( vehicles )} < /Typography> < /> ); } export default Vehicles ; Note If you have a keen eye, you'll see that the Amplify runtime has already created values for the id fields when new did new Vehicle({ make, model, mileage }) . This also happens to be a UUID. Just not one of the ones we assigned explicitly. This explanation's a bit confusing. Sorry about that.","title":"The upshot"},{"location":"releasenotes/","text":"To do \u00b6 Done Move redundant indents from all code samples Todo Fix number of rows in table Use ZenDesk API to create and track work orders","title":"Release notes"},{"location":"releasenotes/#to-do","text":"Done Move redundant indents from all code samples Todo Fix number of rows in table Use ZenDesk API to create and track work orders","title":"To do"},{"location":"table-polish/","text":"Material Table takes options. Lots of options. Let's use a couple of quick ones here. Remove the total number of rows for the display in pagination. const localization = { pagination : { labelDisplayedRows : '{from}-{to}' } } Remove the title and change the way we display pages. const options : Options = { showTitle : false , showFirstLastPageButtons : false , paginationType : \"stepped\" , } So now our Material Table declaration looks like < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } localization = { localization } options = { options } /> Todo More polish needed here Fix screen flash Update total number of rows The upshot \u00b6 We integrated Amplify DataStore and Material Table. I think it was well worth it. It would have taken ages to do this from scratch. There are some wrinkles, but not enough we can't press on. Our final Vehicles.tsx is this import React , { useEffect , createRef } from 'react' ; import { Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { DataStore , SubscriptionMessage } from '@aws-amplify/datastore' ; import MaterialTable , { Column , Query , QueryResult , MaterialTableProps , Options } from 'material-table' const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" , emptyValue : '' }, ]; function Vehicles() { const tableRef = createRef < MaterialTableProps < Vehicle >> (); useEffect (() => { function subscriber ( msg : SubscriptionMessage < Vehicle > ) { console . log ( 'subscription' , msg . opType ); if ( tableRef . current ) { const table = tableRef . current ; if ( table . onQueryChange ) { table . onQueryChange ({ filters : [], orderBy : {}, orderDirection : 'asc' , page : table.page || 0 , pageSize : table.options?.pageSize || 5 , search : table.options?.searchText || '' }); } } }; const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, [ tableRef ]); function rowMapper ( vehicles : Vehicle []) : Vehicle [] { return vehicles . map ( vehicle => { return { ... vehicle } }); } function data ( query : Query < Vehicle > ) : Promise < QueryResult < Vehicle >> { return new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; DataStore . query ( Vehicle , criteria => criteria . or ( orTerms => orTerms . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search ) . mileage ( \"ge\" , parseInt ( query . search ))), thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }); }) . catch ( reject ); }) } const onRowAdd = ( newData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { const add = new Vehicle ({ make : newData.make , model : newData.model , mileage : parseInt ( newData . mileage , 10 ) }); DataStore . save ( add ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const onRowDelete = ( oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . delete ( Vehicle , oldData . id ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const onRowUpdate = ( newData : any , oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . query ( Vehicle , oldData . id ) . then ( original => { const updated = Vehicle . copyOf ( original , updated => { updated . make = newData . make updated . model = newData . model updated . mileage = parseInt ( newData . mileage , 10 ) }); return DataStore . save ( updated ); }) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , onRowDelete , onRowUpdate } const localization = { pagination : { labelDisplayedRows : '{from}-{to}' } } const options : Options = { showTitle : false , showFirstLastPageButtons : false , paginationType : \"stepped\" , } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } > < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } localization = { localization } options = { options } /> < /Grid> < /Grid> ); } export default Vehicles ;","title":"Polish"},{"location":"table-polish/#the-upshot","text":"We integrated Amplify DataStore and Material Table. I think it was well worth it. It would have taken ages to do this from scratch. There are some wrinkles, but not enough we can't press on. Our final Vehicles.tsx is this import React , { useEffect , createRef } from 'react' ; import { Grid } from '@material-ui/core' ; import { Vehicle } from './models' ; import { DataStore , SubscriptionMessage } from '@aws-amplify/datastore' ; import MaterialTable , { Column , Query , QueryResult , MaterialTableProps , Options } from 'material-table' const columns : Column < Vehicle > [] = [ { title : 'Make' , field : 'make' }, { title : 'Model' , field : 'model' }, { title : 'Mileage' , field : 'mileage' , type : \"numeric\" , emptyValue : '' }, ]; function Vehicles() { const tableRef = createRef < MaterialTableProps < Vehicle >> (); useEffect (() => { function subscriber ( msg : SubscriptionMessage < Vehicle > ) { console . log ( 'subscription' , msg . opType ); if ( tableRef . current ) { const table = tableRef . current ; if ( table . onQueryChange ) { table . onQueryChange ({ filters : [], orderBy : {}, orderDirection : 'asc' , page : table.page || 0 , pageSize : table.options?.pageSize || 5 , search : table.options?.searchText || '' }); } } }; const subscription = DataStore . observe ( Vehicle ) . subscribe ( subscriber ); return () => { subscription . unsubscribe (); }; }, [ tableRef ]); function rowMapper ( vehicles : Vehicle []) : Vehicle [] { return vehicles . map ( vehicle => { return { ... vehicle } }); } function data ( query : Query < Vehicle > ) : Promise < QueryResult < Vehicle >> { return new Promise (( resolve , reject ) => { const thisPage = { page : query.page , limit : query.pageSize }; DataStore . query ( Vehicle , criteria => criteria . or ( orTerms => orTerms . make ( \"contains\" , query . search ) . model ( \"contains\" , query . search ) . mileage ( \"ge\" , parseInt ( query . search ))), thisPage ) . then ( vehicles => { resolve ({ data : rowMapper ( vehicles ), page : query.page , totalCount : 1000000 }); }) . catch ( reject ); }) } const onRowAdd = ( newData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { const add = new Vehicle ({ make : newData.make , model : newData.model , mileage : parseInt ( newData . mileage , 10 ) }); DataStore . save ( add ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const onRowDelete = ( oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . delete ( Vehicle , oldData . id ) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const onRowUpdate = ( newData : any , oldData : any ) => new Promise (( resolve , reject ) => { const timeout = setTimeout (() => { DataStore . query ( Vehicle , oldData . id ) . then ( original => { const updated = Vehicle . copyOf ( original , updated => { updated . make = newData . make updated . model = newData . model updated . mileage = parseInt ( newData . mileage , 10 ) }); return DataStore . save ( updated ); }) . then ( result => { clearTimeout ( timeout ) resolve ( result ); }) . catch ( reject ) }, 1000 ); }) const editable = { onRowAdd , onRowDelete , onRowUpdate } const localization = { pagination : { labelDisplayedRows : '{from}-{to}' } } const options : Options = { showTitle : false , showFirstLastPageButtons : false , paginationType : \"stepped\" , } return ( < Grid container spacing = { 2 } > < Grid item xs = { 12 } > < MaterialTable tableRef = { tableRef } data = { data } columns = { columns } editable = { editable } localization = { localization } options = { options } /> < /Grid> < /Grid> ); } export default Vehicles ;","title":"The upshot"},{"location":"thanks/","text":"Thanks to my friends and erstwhile colleagues, Darren and Misha. They generously and patiently taught me everything I know about React. More importantly, many other things besides. They know. Thank you.","title":"Acknowledgements"},{"location":"tools/","text":"To get going with this tutorial, you'll need some tools. Please follow the links for instructions. Then come back here where we'll kick the tires to see whether the setup worked. Install \u00b6 Tool Required? Installation instructions Amazon Web Services account Yes https://aws.amazon.com/console/ AWS Access Key Yes https://www.youtube.com/watch?v=665RYobRJDY nodejs Yes https://nodejs.org/en/download/package-manager/ yarn package manager Yes https://classic.yarnpkg.com/en/docs/install TypeScript Yes, all the docs assume TypeScript https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#installing-typescript AWS CLI Optional, but super useful https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html GitHub account Optional https://github.com Did the installations work? \u00b6 No let's check everything opens and shuts. AWS account \u00b6 You will have the file ~/.aws/credentials after an AWS account has been set up. It looks like [default] aws_access_key_id=YOUMUSTBEKIDDING aws_secret_access_key=GETYOUROWNLEYS Test whether the AWS CLI works aws iam get-account-password-policy The result should be something like { \"PasswordPolicy\" : { \"MinimumPasswordLength\" : 8 , \"RequireSymbols\" : true , \"RequireNumbers\" : true , \"RequireUppercaseCharacters\" : true , \"RequireLowercaseCharacters\" : true , \"AllowUsersToChangePassword\" : true , \"ExpirePasswords\" : false , \"HardExpiry\" : false } } Does yarn work? \u00b6 Try yarn help You should see Usage: yarn [command] [flags] Displays help information. Options: --cache-folder <path> specify a custom folder that must be used to store the yarn cache --check-files install will verify file tree of packages for consistency ... The upshot \u00b6 ... TBD Todo Links to fixing installation failures.","title":"Install the tools"},{"location":"tools/#install","text":"Tool Required? Installation instructions Amazon Web Services account Yes https://aws.amazon.com/console/ AWS Access Key Yes https://www.youtube.com/watch?v=665RYobRJDY nodejs Yes https://nodejs.org/en/download/package-manager/ yarn package manager Yes https://classic.yarnpkg.com/en/docs/install TypeScript Yes, all the docs assume TypeScript https://www.typescriptlang.org/docs/handbook/typescript-in-5-minutes.html#installing-typescript AWS CLI Optional, but super useful https://docs.aws.amazon.com/cli/latest/userguide/install-cliv2.html GitHub account Optional https://github.com","title":"Install"},{"location":"tools/#did-the-installations-work","text":"No let's check everything opens and shuts.","title":"Did the installations work?"},{"location":"tools/#aws-account","text":"You will have the file ~/.aws/credentials after an AWS account has been set up. It looks like [default] aws_access_key_id=YOUMUSTBEKIDDING aws_secret_access_key=GETYOUROWNLEYS Test whether the AWS CLI works aws iam get-account-password-policy The result should be something like { \"PasswordPolicy\" : { \"MinimumPasswordLength\" : 8 , \"RequireSymbols\" : true , \"RequireNumbers\" : true , \"RequireUppercaseCharacters\" : true , \"RequireLowercaseCharacters\" : true , \"AllowUsersToChangePassword\" : true , \"ExpirePasswords\" : false , \"HardExpiry\" : false } }","title":"AWS account"},{"location":"tools/#does-yarn-work","text":"Try yarn help You should see Usage: yarn [command] [flags] Displays help information. Options: --cache-folder <path> specify a custom folder that must be used to store the yarn cache --check-files install will verify file tree of packages for consistency ...","title":"Does yarn work?"},{"location":"tools/#the-upshot","text":"... TBD Todo Links to fixing installation failures.","title":"The upshot"}]}